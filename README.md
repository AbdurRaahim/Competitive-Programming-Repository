# Competitive-Programming-Repository
Collection of algorithms and data structures in C++ used widely in Competitive programming contests. 

### The following topics are covered:

#### Range Updates and Queries
* **Range Aggregate Queries** :
  * *Binary Indexed Trees (BIT)* :
    * [Point Update Range Query](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/binary_indexed_tree.cpp)
    * [Range Update Range Query](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/binary_indexed_tree_range_query_range_update.cpp)
    * [Order Statistic Query](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/binary_indexed_tree_order_stat.cpp)
    * [2D Binary Indexed Trees](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/binary_indexed_tree_2D.cpp)
  * *Segment Trees (SegTree)* :
    * [Point Update Range Query](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_tree_range_query_point_update.cpp) 
    * [Fast Iterative Segtrees](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_trees_interative_fast.cpp)
    * [Range Update Point Query - Lazy Propogation](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_tree_range_query_range_update_lazy_propogation.cpp)
    * [Max subsegment sum in range](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_tree_custom_merge_function.cpp)
    * [2D Segment Trees](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_tree_2D.cpp)
    * [Dynamic Segment Trees - Insertion/Deletion between elements](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_tree_dynamic_using_treaps.cpp)
    * [Dynamic Segment Trees - Reverse a segment](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_tree_dynamic_reverse_subarray_using_treap.cpp)
  * *Merge Sort Trees* :
    * [Merge sort trees](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/merge_sort_trees.cpp)
    * [Merge sort trees - Order Statistics](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/merge_sort_trees_order_stat_query.cpp)  
  * *Sparse Table* :
    * [Range Minimum Query](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/range_minimum_query_sparse_table.cpp)
  * *Mo Algorithm* :
    * [Mo Algorithm - Arrays](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/mo_algorithm_offline_range_query.cpp)
* **Dynamic Programming** :
  * *Dynamic Programming Templates* :
    * [Digit DP / Bitwise DP](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/dynamic_programming_templates.cpp)
  * *Standard DP Problems* :
    * [Longest Increasing Subsequence](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/longest_increasing_subsequence_lis_binary_search.cpp)
    * [Longest Palindromic Subsequence](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/palindrome_longest_subsequence.cpp)
    * [Levenstein Distance / Edit Distance](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/edit_distance_levenstein_dynamic_programming.cpp)
* **Graphs** :
  * *Single Source Shortest Path Algorithms* :
    * [Dijkstra in dense graphs](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/dijsktra_dense_graphs.cpp)
    * [Dijkstra using priority queue](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/dijkstra_using_priority_queue.cpp)
    * [Kth Shortest Path between Nodes using Dijkstra](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/kth_shortest_path_between_nodes_graph.cpp)
    * [Bellman Ford Negative cycle detection](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/bellman_ford.cpp)
  * *All Pair shortest path* :
    * [Using Binary exponentiation](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/all_pair_shortest_path_binary_exponentation.cpp)
    * [Floyd Warshall](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/all_pair_shortest_path_floyd_warshall.cpp)
  * *Cycle Detection* :
    * [Cycle detection in Undirected/Directed Graphs](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/cycle_detection_in_graph.cpp)
  * *Minimum Spanning tree* :
    * [Kruskal Algorithm](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/kruskal_min_spanning_tree.cpp)
  * *Topological Sort / Strongly Connected Component* :
    * [Topological Sort](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/topological_sort_kosaraju.cpp)
    * [Strongly Connected Component](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/strongly_connected_components_kosaraju.cpp) 
  * *Maxflow/Matching* :
    * [Hopkroft Karp Max Matching](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/max_bipartite_matching_hopcroft_karp.cpp)
    * [Dinic Max Flow](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/max_flow_network_dinic_algorithm.cpp)
  * *Misc* :
    * [Bridges in Graph](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/bridges_in_graph.cpp)
    * [Connectivity](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/isConnected_using_bfs.cpp)
    * [Bipartite Check](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/non_bipartite_check.cpp)
* **Trees** :
    * *Ancestor queries* :
        * [Lowest Common Ancestor](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/lowest_common_ancestor_lca.cpp)
        * [Kth Ancestor](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/kth_ancestor_tree.cpp)
    * *Path queries* :
        * [Sparse Table](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/trees_path_query_sparse_tables.cpp)
        * [Heavy Light Decomposition Weighted Nodes](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/heavy_light_decomposition_wieghted_vertices(hld).cpp)
        * [Heavy Light Decomposition Weighted Edges](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/heavy_light_decomposition_weighted_edges%20(hld).cpp)
    * *Misc* :
        * [Diameter of Tree](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/tree_diameter.cpp)
        * [Preorder/Postorder stamps, Is it in Subtree?](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/tree_dfs_preorder_postorder_isInSubtree.cpp) 
* **Binary Exponentiation** :
   * [Calculate n^m using Binary exponentiation](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/power_binary_exponentiation.cpp)
   * [Solving Linear Recurrences](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/linear_recurrence_matrix_exponentiation.cpp)
* **Strings** :
   * *String Algorithms* :
       * [Z Algorithm](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/Z_algorithm_max_prefix_match.cpp)
       * [Rolling String Hashing](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/string_hashing.cpp)
       * [Rolling String Hashing for Dynamic Strings](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/string_hashing_dynamic_segment_trees.cpp)
* **Sorting** :
  * [Merge Sort](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/merge_sort_count_inversion.cpp)
  * [Quick Select](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/quick_select_order_stat_linear.cpp)
* **Fast Input/Output, String/Integer Conversion** :
   * [Fast Input/Output](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/fast_readInt_writeInt_function.cpp)
   * [String/Integer Conversion](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/int2string_string2int.cpp)
* **Misc. Data Structures** :
   * [Disjoint Set](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/disjoint_set.cpp)
   * [Disjoint Set (Supports Undo Operation)](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/disjoint_set_with_undo_operation.cpp)
   * [Max/Min Priority Queue with update](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/heap_using_multiset_max_min_insert_erase_update.cpp)
   * [Binary Trie for xor maximization/minimization](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/binary_trie_max_xor.cpp)
   * [Bigint](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/bigint_library.cpp)
   * [Augmented Binary Tree for order statistics and rank query](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/orderstat_rank_query_augmented_bst.cpp)
   * [Monotone Priority Queue](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/monotone_priority_queue.cpp)
   * [Trie](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/trie_insertion_deleteion.cpp)
* **Persistent Data Structures** :
  * *Persistent Segment Trees (SegTree)* :
    * [Persistent Segment Tree](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_tree_persistent.cpp)
    * [Persistent Segment Tree - Order Statistics](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segment_tree_persistent_order_stat.cpp)
* **Number Theory Algorithms** :
  * *Primality Check* :
      * [Fermat's Primality Check](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/primality_check_fermat.cpp)
  * *Sieve* :
      * [Sieve of Eratosthenes](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/prime_sieve.cpp)
      * [Segmented Sieve for large primes](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/segmented_sieve_large_primes.cpp)
      * [Counting Prime Factors](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/prime_factor_count.cpp)
  * *Polynomial Multiplication* :
      * [Fast Fourier Tranform](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/fast_fourier_transform_fft.cpp)
      * [Karatsuba](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/karatsuba_polynomial_multiplication.cpp)
  * *Misc* :
      * [Combinatorial and Catalan - Factorial preprocessing](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/factorial_preprocessing.cpp)
      * [Mobeius Function](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/mobeius_function.cpp)
      * [Euler Totient Function](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/euler_phi_euler_totient_function.cpp)
      * [Lucas Theorm - Combinatorics](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/master/lucas_combinatorics.cpp)  
* **Misc** :
  * [Sum of floor(x) with x=1:n](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/aggreate_sqrt_distinct_values.cpp)
  * [Sum of cyclic functions](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/aggregate_cyclic_function.cpp)
  * [Closest larger element before/after every element](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/closest_max_element_before_after_index_using_stack.cpp)
  * [Multiply Long Long Integers](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/multiply_longlong_integers.cpp)
  * [Multiply Long Long Integers - Overflow detection](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/multiply_detect_overflow.cpp)
  * [Scanline - Merge intersecting intervals](https://github.com/dragonslayerx/Competitive-Programming-Repository/blob/dragonslayerx-readme-update/scanline_merge_overlapping_intervals.cpp)
  
  
      
      
  
  
   
   


















